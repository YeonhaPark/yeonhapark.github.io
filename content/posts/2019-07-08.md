---
title: "TIL - 자바스크립트 ES6 - Promises "
date: "2019-07-08"
template: "post"
draft: true
slug: "/posts/javascript-promises/"
category: "javascript"
tags:
  - "promises"
  - "es6"
  - "javascript"
description: "자바스크립트 비동기 처리 방식 중 하나인 Promises에 대해."
---

### 자바스크립트 비동기 처리 방식 중 하나인 Promises에 대해서 정리해보았다

**Promises란?**

Promise 는 비동기 프로그래밍의 궁극적인 결과를 나타내는 오브젝트다.

프로미스가 리턴하는 값은 pending, fulfilled, rejected 세 개의 상태를 갖는데, 뒤의 두 개 상태를 settled라고 표현한다.

Promise는 new 생성자로 생성하며 하나의 콜백 함수를 받는다. 이 콜백함수는 executor function이라고 불리는데, 여기서 실행 결과를 정의해주므로 그 역할이 중요하다. Executor function은 resolve, reject 두 개의 인자를 가진다.

```javascript
const inventory = {
	sunglasses: 1900,
	pants: 1088,
	bags: 1344
};

const myExecutor = (resolve, reject) => {
	if (inventory.sunglasses > 0) {
		resolve("Sunglasses order processed.");
	} else {
		reject("That item is sold out.");
	}
};

const orderSunglasses = () => {
	return new Promise(myExecutor);
};

const orderPromise = orderSunglasses();

console.log(orderPromise);
```

비동기 프로미스의 첫번째 상태는 pending(대기중)이다. 이 상태는 결국에는 settled(either rejected or fulfilled) 로 변할 것이다. Promise는 .then()메서드와 같이 오는데, 다음 문장을 들으면 이해가 더 쉽다. "I have a promise. When it settles **then** here's what's going to happen.."

.then은 함수를 인자로 받는 고차 함수이다. 두 개의 콜백함수를 받는데, 이를 handler라고 표현한다. 명료한 코딩을 위해 두 개의 콜백을 모두 정의해주는 것이 좋겠지만, 핸들러가 하나도 없어도 then은 작동한다! .then()은 프로미스를 리턴할 것이다.

```javascript
const { checkInventory } = require("./library.js");

const order = [["sunglasses", 1], ["bags", 2]];

// Write your code below:
const handleSuccess = resolvedValue => {
	return console.log(resolvedValue);
};

const handleFailure = failedValue => {
	return console.log(failedValue);
};

checkInventory(order).then(handleSuccess, handleFailure);
```

```javascript
const { checkInventory } = require("./library.js");

const order = [["sunglasses", 1], ["bags", 2]];

const handleSuccess = resolvedValue => {
	console.log(resolvedValue);
};

const handleFailure = rejectReason => {
	console.log(rejectReason);
};

checkInventory(order)
	.then(handleSuccess)
	.catch(handleFailure);
```

위에서 쓰인 catch는 Promise의 다른 메서드이다. catch가 받는 아규먼트는 오직 reject이기떄문에 코드 분리를 통해 효율성을 달성하는 측면에서 효과적이다.
(참고: Separation of concerns : 코드를 모듈처럼 기능 별로 설계하여 문제가 발생했을 때 빠르고 효과적으로 해당 섹션에 침투할 수 있도록 하는 원칙이다)
[Separations of concerns 개념 보기](https://en.wikipedia.org/wiki/Separation_of_concerns)

###Promise 의 Composition, Chaining

프로미스를 생성하고, 그 결과를 리턴 받는 것으로 끝날 수도 있지만, 함수의 결과가 다른 함수로 이어지고 그 함수의 리턴값이 또 다른 함수를 호출하는 현상은 자바스크립트를 하는 사람이라면 아주 손쉽게 접하고 구현하게 된다. 여러 개의 프로미스를 Chaining하는 과정을 composition이라고 명한다. 아래 코드를 참고해보자. 두번째 then에 첫번째 then 결과를 넘기려면 반드시 return을 써야 한다는 것을 명심하자.

```javascript
firstPromiseFunction() // 1. firstPromiseFunction을 호출합니다.
	.then(firstResolveVal => {
		// 2. then이 호출되며 secondPromiseFunction을 호출
		return secondPromiseFunction(firstResolveVal);
	})
	.then(secondResolveVal => {
		// 3. 두번째 then을 호출
		console.log(secondResolveVal);
	});
```

###Concurrency

위의 경우와 반대로, 하나의 프로미스가 다른 프로미스의 결과에 종속적이지 않을 수도 있다. 여러 프로미스의 결과를 resolve 혹은 reject 로 나타내고 싶다면 Promise.all()을 사용한다. Promise.all()은 어레이 형태로 된 프로미스를 아규먼트로 받고 하나의 프로미스를 리턴한다.

- 어레이 내 모든 프로미스가 리졸브되면 어레이 내 프로미스의 리졸브 값을 각각 리턴할 것이다.
- 어레이 내 프로미스 중 하나라도 리젝트되면 Promise.all()은 곧바로 리젝트된 프로미스의 리젝트 reason을 리턴할 것이다.

```javascript
let myPromises = Promise.all([
	returnsPromOne(),
	returnsPromTwo(),
	returnsPromThree()
]);

myPromises
	.then(arrayOfValues => {
		console.log(arrayOfValues);
	})
	.catch(rejectionReason => {
		console.log(rejectionReason);
	});
```

<i>정리를 위해 Codecademy의 예제 코드를 사용했습니다</i>
