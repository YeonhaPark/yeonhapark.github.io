{"componentChunkName":"component---src-templates-post-template-js","path":"/blog/react-optimization-using-memoization/","result":{"data":{"markdownRemark":{"excerpt":"React useCallback을 통한 성능 최적화 eslint문법을 적용하고 개발을 하다보면 한번씩 react-hooks/exhaustive-deps 에러를 맞닦뜨리는 경험을 하게 된다. 가  넣으라고 해서 넣었는데, 위 코드는 infinite loop…","html":"<h1>React</h1>\n<h3>useCallback을 통한 성능 최적화</h3>\n<p>eslint문법을 적용하고 개발을 하다보면 한번씩 react-hooks/exhaustive-deps 에러를 맞닦뜨리는 경험을 하게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">getAllPosts</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">...</span><span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">...</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">getAllPosts</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>getAllPosts<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">eslint</code>가 <code class=\"language-text\">dependency</code> 넣으라고 해서 넣었는데, 위 코드는 infinite loop를 불러일으킨다 ☹️ infinite loop는 왜 생기는걸까?</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">common</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">a<span class=\"token punctuation\">,</span> b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> a <span class=\"token operator\">*</span> b<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> multiply1 <span class=\"token operator\">=</span> <span class=\"token function\">common</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> multiply2 <span class=\"token operator\">=</span> <span class=\"token function\">common</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nmultiply1 <span class=\"token operator\">===</span> multiply2<span class=\"token punctuation\">;</span> <span class=\"token comment\">// false 다른 참조값</span>\nmultiply1 <span class=\"token operator\">===</span> multiply1<span class=\"token punctuation\">;</span> <span class=\"token comment\">// true 같은 참조값</span></code></pre></div>\n<p><code class=\"language-text\">multiply1</code>과 <code class=\"language-text\">multiply2</code>는 <code class=\"language-text\">common</code>이라는 같은 함수에서 출발했지만 엄연히 다른 함수 오브젝트이다. </p>\n<p>위의 코드에서도 컴포넌트가 렌더 할때마다 <code class=\"language-text\">getAllPosts</code>라는 함수가 재생성되어 <code class=\"language-text\">useEffect</code>의 실행을 trigger한다. 그리고 이것이 다시 렌더를 일으키고 <code class=\"language-text\">getAllPosts</code>라는 함수가 재생성되고, <code class=\"language-text\">useEffect</code> 실행을 trigger하는 과정이 반복된다. ⇒ Infinite Loop로 이어진다</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">getAllPosts</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">...</span><span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">...</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">getAllPosts</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>getAllPosts<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 렌더마다 function이 재생성된다.</span></code></pre></div>\n<p>이런 상황에서 <code class=\"language-text\">useCallback</code>을 쓸 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> getAllPosts <span class=\"token operator\">=</span> <span class=\"token function\">useCallback</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n     <span class=\"token comment\">// ...</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n     <span class=\"token comment\">// ...</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>searchTag<span class=\"token punctuation\">,</span> searchWords<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// dependencies</span></code></pre></div>\n<p><code class=\"language-text\">useCallback</code>을 사용하면 getAllPosts라는 변수는 리렌더링 중에도 항상 같은 콜백 함수로, 렌더 시마다 재생성되지 않아 useEffect를 트리거하지 않는다. 다만 dependency를 두번째 인자로 넘길 수 있는데, 이 dependency가 바뀔때마다 바뀐다.</p>\n<p><code class=\"language-text\">useCallback(fn, deps)</code> 은 <code class=\"language-text\">useMemo(() => fn, deps)</code> 와 같다.</p>\n<h3>React.memo를 통한 성능 최적화</h3>\n<p>리액트 컴포넌트의 prop이나 state가 바뀔 때 re-rendering이 발생한다. 그리고 그 컴포넌트의 자식들(children)도 리렌더가 된다. 함수형 컴포넌트에서는 자식 컴포넌트가 불필요하게 리렌더링 되는 현상을 방지하기 위해 <code class=\"language-text\">React.memo()</code> 를 쓸 수 있다. (클래스형 컴포넌트에서는 <code class=\"language-text\">shouldComponentUpdate()</code> 로 라이프사이클 제어가 가능하다)</p>\n<p>프로그래밍에서 이런 memoization 은 최적화 테크닉으로 자주 쓰인다. </p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">multiply</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">a<span class=\"token punctuation\">,</span> b</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">return</span> a <span class=\"token operator\">*</span> b<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 함수에서 a, b 값으로 2, 3 이라는 동일한 값을 입력한다면 어느 시점에 값을 입력하던지 항상 같은 결과가 나올 것이다. memoization은 <strong>같은 인풋</strong>이 반복되는 사항에 대해 <strong>캐시된 결과값</strong>을 리턴한다. </p>\n<p><code class=\"language-text\">Button</code> 컴포넌트는 <code class=\"language-text\">Note</code> 컴포넌트의 <code class=\"language-text\">state</code>값이 변할때마다 리렌더된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">//...</span>\n<span class=\"token keyword\">import</span> Buttom <span class=\"token keyword\">from</span> <span class=\"token string\">'./Button'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span> <span class=\"token function\">Note</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>words<span class=\"token punctuation\">,</span> setWords<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n\t\t<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n\t\t\t</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">onChange</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">e</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">setWords</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span></span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>text<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n\t\t\t</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Button</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n\t\t</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n\t<span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>아래 링크에서 <code class=\"language-text\">React.memo()</code> 를 사용한 컴포넌트와 그렇지 않은 컴포넌트의 차이를 확인할 수 있다.</p>\n<p><a href=\"https://codesandbox.io/s/2x5z13y4p?file=/src/index.js:344-356\">https://codesandbox.io/s/2x5z13y4p?file=/src/index.js:344-356</a></p>\n<p>리액트 컴포넌트의 prop 이나 state가 바뀔 때 리렌더가 된다. 그리고 그 컴포넌트의 자식들도 리렌더가 된다. 클래스형 컴포넌트에서는  shouldComponentUpdate()로 라이프사이클 제어가 가능했는데, 함수형 컴포넌트를 이를 대신하기 위해 React.memo()를 쓸 수 있다. </p>\n<p>참고한글</p>\n<p><a href=\"https://velog.io/@cjh951114/%EC%A7%81%EB%AC%B4-%EA%B4%80%EB%A0%A8-%EC%A7%88%EB%AC%B8-06.-%ED%94%84%EB%9F%B0%ED%8A%B8%EC%97%94%EB%93%9C-%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94%EB%9E%80\">https://velog.io/@cjh951114/직무-관련-질문-06.-프런트엔드-성능-최적화란</a>\n<a href=\"https://mingule.tistory.com/66\">https://mingule.tistory.com/66</a>\n<a href=\"https://dmitripavlutin.com/dont-overuse-react-usecallback/\">https://dmitripavlutin.com/dont-overuse-react-usecallback/</a>\n<a href=\"https://reactjs.org/docs/hooks-reference.html#usecallback\">https://reactjs.org/docs/hooks-reference.html#usecallback</a></p>","frontmatter":{"title":"useCallback과 React.memo를 통한 리액트 성능 최적화","tags":["react","optimization"],"date":"November 15, 2021","description":null}},"prev":{"frontmatter":{"title":"JavaScript Iterable"},"fields":{"slug":"/blog/javascript-iterable/"}},"next":{"frontmatter":{"title":"이벤트 버블링과 캡처링"},"fields":{"slug":"/blog/event-bubbling/"}}},"pageContext":{"slug":"/blog/react-optimization-using-memoization/","prevSlug":"/blog/javascript-iterable/","nextSlug":"/blog/event-bubbling/"}},"staticQueryHashes":["2555585279","2841359383","3159585216"]}