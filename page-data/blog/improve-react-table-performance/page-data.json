{"componentChunkName":"component---src-templates-post-template-js","path":"/blog/improve-react-table-performance/","result":{"data":{"markdownRemark":{"excerpt":"React Table은 Table을 그리는데 필요한 다양한 API와 무엇보다도 useRowSelect를 활용한 행 단위 데이터 선택 기능, 체크박스 기능 등을 제공하고 있어 테이블 상에서 이뤄지는 다양한 작업을 커버하기에 유용한 라이브러리이다. 하지만 업무에서 React Table…","html":"<p>React Table은 Table을 그리는데 필요한 다양한 API와 무엇보다도 useRowSelect를 활용한 행 단위 데이터 선택 기능, 체크박스 기능 등을 제공하고 있어 테이블 상에서 이뤄지는 다양한 작업을 커버하기에 유용한 라이브러리이다.</p>\n<p>하지만 업무에서 React Table을 사용하다 보니 단점을 경험하게 되었다. 업무에서는 fetch한 데이터를 다양한 방식으로 가공하여 React Table로 렌더하고, 렌더된 DOM 상에서 사용자가 인터렉션할 수 있도록 여러 기능을 제공하고 있다. 하지만 하나의 테이블에 워낙 많은 기능이 들어가다 보니 일반 사용자가 느끼기에도 현저하게 성능이 저하되는 문제가 발생하였다. 지금 개발중인 프로덕트는 infinite scrolling 방식으로 동작하는데, 첫번째 로드 시 50개 리스트를 불러오고, concat으로 추가 fetch 요청이 발생할 때마다 50개씩 리스트를 덧붙이면서 리스트의 숫자가 매번 fetch가 일어날 때마다 배로 늘어나고, 로드되는 속도는 리스트의 갯수에 비례하여 현저히 느려졌다.</p>\n<p>이런 성능 저하에 기여한 요인 중에 상당한 부분이 React Table의 렌더링 방식인데, 사용자가 하나의 셀만 클릭하더라도 테이블을 구성하는 모든 행이 다시 렌더된다. React Table 측에서는 이를 개선해야할 점이라기 보다는 모든 셀을 최신 상태로 유지하기 위해 라이브러리가 선택한 메커니즘으로 설명하고 있다.</p>\n<p><a href=\"https://github.com/TanStack/table/issues/1496\">https://github.com/TanStack/table/issues/1496</a></p>\n<p>React Table의 작동 방식을 설명하기 위해 codesandbox로 예시를 작성하였다. React devtool의 Profiler 탭에 있는 rerender highlight 기능을 키고 해당 예시를 작동해보자.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/fafe45553ed58f09fbafca12b4b2284a/6b26f/react-table-only.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 94.9367088607595%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAABYlAAAWJQFJUiTwAAAC5ElEQVQ4y41U2ZLiOBDk/39r3vZpj2Ea3xduY+MDybJ1mc6JKgM927MP64gMIZnKqswUHJq/vuEU/4Hvfx9RNy2EXLCsFtpuaJsL4uM/KOMQRRS8kIdPnB6g85DXg7EOalboxhlVMyAu3tFcBZS546YsBqFxHX/BpDHKHXJxkIvHNBuup/WweQ+3eRjvMckZ401gFBJKG1i/YV4dklIirSSiQqCbDG5qQZDmqLsrqkuLbrohKisoY3HwROg9tLW4Dj2uw4Cuv2I1BvePO+bVIswlolwiSAXaQeOmZvx5/I5jEOBHGKK5dkirCtpZHJxzUMbAbBsmNfOLQQiY+4bVWeTnGUEicIpvCFOCQN0JREWOIMsQZCnKpkF6PmO1T0KtMWvyZ0JWVWjHAVKvfJZWCmFKIGKaVKFqBaI8Q5TnOHctLsPAhDwhSdZaYxxHDCS363jt+57PL/2CKL8hLQXi4oaintGOguW+RRGCNEE7jsjrep+QCBdroVmyQnW5YJxn3i/OwW8b3q8LTqlAXEpos0EohSBJULct6vaCtu+RPSUzoTFcPEqJ4r1GL268p0b0dMOKt2hCUgreL3rBMYoQZil7ful7xEXx71BW7zFIyR6Sl9p7SG0QFzOibMaPUHDKSbEgbybEZc5kb0nCqvLmnUNkwuWRMqWbFMVOuO1WSOWQljOnG2YC3WAwSsVEpzR9ESbnaie83+9cOFsDqTX7KChhmtpZvovdpNBOCpdB8eU1zqLpe3TjiG4aeZC663bCj48PrM4xgbKWvVOPBouz3IzW1e/g71jLiuy2vdbVO2jnPgmVNb+BComAPCY8m8rH5/l1ZlgVE5Jk7R2T6v8JVkBkdgfthdZ7yp8T2i8wXGy93+U/zp6N5ZPQ/AchefRVBu2JZLvfX8XSaP5XIlANEXMD7x4D/BbKU8JOSkWvW/Bo5CgI718eP0OjZq9Qli+ePKX8OqF6TEjT2MfPdXWf3lNoNOFPe5GqUXnFX/MAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"react-table only\"\n        title=\"react-table only\"\n        src=\"/static/fafe45553ed58f09fbafca12b4b2284a/f058b/react-table-only.png\"\n        srcset=\"/static/fafe45553ed58f09fbafca12b4b2284a/c26ae/react-table-only.png 158w,\n/static/fafe45553ed58f09fbafca12b4b2284a/6bdcf/react-table-only.png 315w,\n/static/fafe45553ed58f09fbafca12b4b2284a/f058b/react-table-only.png 630w,\n/static/fafe45553ed58f09fbafca12b4b2284a/40601/react-table-only.png 945w,\n/static/fafe45553ed58f09fbafca12b4b2284a/78612/react-table-only.png 1260w,\n/static/fafe45553ed58f09fbafca12b4b2284a/6b26f/react-table-only.png 1658w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p><a href=\"https://codesandbox.io/s/react-table-only-v74rko\">https://codesandbox.io/s/react-table-only-v74rko</a></p>\n<p>테이블 공간에 부여한 높이는 400px 이지만 실제 데이터의 숫자만큼 렌더가 되서 노출되지 않는 영역까지 리소스가 소비되고 있다. React-Table에서 column을 구성할 때 Cell 프로퍼티를 사용하여 데이터를 가공한다면 위와 같이 어떤 셀을 조작하더라도 렌더링 대상에 포함된다.</p>\n<p>이런 특징 때문에 React Table에서도 react window같은 가상화(Virtualization) 테크닉을 사용하는 것을 홈페이지에 대안으로 제시하기도 하였다. (<a href=\"https://react-table-v7.tanstack.com/docs/examples/virtualized-rows\">https://react-table-v7.tanstack.com/docs/examples/virtualized-rows</a>)</p>\n<p>목록 가상화: 목록 가상화 혹은 윈도윙(windowing)이라고 불리며 사용자에게 보이는 영역에 한해 리스트를 렌더링하는 테크닉이다.</p>\n<p>react-window는 table 태그를 지원하지 않아 react-virtuoso를 대신 사용하였다.</p>\n<p>react-virtuoso를 사용하게 되면 style로 입혀준 height 높이에 해당하는 만큼만 렌더가 이뤄지고, 창의 크기를 벗어나면 더이상 렌더되지 않는다. 아이템의 갯수가 1000개, 2000개 넘어가더라도 창의 크기에 해당하는 행의 갯수는 고정이니 대량의 데이터를 렌더링하는 경우에 성능 개선의 효과를 볼 수 있다. 내 경우엔 데이터의 갯수는 아주 많지 않았지만 테이블의 셀(td)마다 다양하고 복잡한 로직과 UI를 지원해야했고 컴팩트한 기능이 들어가다 보니 속도 개선이 필수적인 상황이었다. react-virtuoso를 사용한 가상화로 infinite scrolling으로 인해 리스트가 축적됨에도 페이지가 증가함에 따라 로딩이 현저하게 느려지는 오류를 개선할 수 있었다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 85.44303797468356%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAABYlAAAWJQFJUiTwAAACnUlEQVQ4y72TXWvcRhSG9///kd6ksWNoCnHchFAKJaUUWie2k7Vs7a529K2ZkTRf2n3KzDq9KKXQXPTiZfRK6JnznjmzenvxjKuX3/Du8iVXF8+5uviWHy6e8eP357z97oyf37zi7tefePz9PZvrX/j8/h2/vXrOH1cvuH79gg+vz7m+POfD5RnXl2es/Dwy6pZS7Pl0d8vd7Q3Z/ZpiuyXPc8qqphskvVTUbU/T9QghEKWg2BdJJ18mrZy3WOvY7bZM88RsJqydqeuKtq1xzjBNinlW7HaPWDsyzRpjDDc3H9lsNoTgsNawhIWVdTPLEgiL53BYTh/djJQdSvXp2diJqlLUtabrRqTq2IsdWbZGiAKlh/QfR1gZO+O9x1iDDx7rLMZM9EPHILsEi+/qRlJWA30/Mk6apq25z9ZsNjlSDfjgOB6PrGJE5x2zmXHBM0WY7tlXe0Qj6PXAMCryouU+r9lXA83QUNbiBNzlDKonti4BRzNiYp9i77wl+i5GqvdJEd5ryeOuItuUbEVDK1uKsuD28y2P20fkKFOKBJzsfKowRo8V2jlVJZqSsi2Rk6STkrxokjb7hrbvKETBOluTb3PKukqMBLTu1LsvPQwhJCmt0KNmOQSkdFSVoW0tRaHoOk3T1GRZlk5ZKZkO9lShs/hlwTiXVhsCo3M0w0ArJZNz2OCpuom8UPTaoM2EqGvWDw9keU6vFS48AQczM3uHtobZe6IXWrLpWrZdi9CKWmvydiCrena9RMiBoq65y+552G5ptcJ4DxEYTycs4RR3CSzLkubROZt0ms3oA9b6tPoQmKYJYy2zMaldf0WONyFClgT7Fx2e9OTjRl8UL0UI/gT0aX5I5msVC/ob8MjhcPgq/b/A/xr1n4B/Aq/MFXc2Vj79AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"react-table-with-virtuoso\"\n        title=\"react-table-with-virtuoso\"\n        src=\"/static/204ce51fbe264a47e9b09154c3654ade/f058b/react-table-with-virtuoso.png\"\n        srcset=\"/static/204ce51fbe264a47e9b09154c3654ade/c26ae/react-table-with-virtuoso.png 158w,\n/static/204ce51fbe264a47e9b09154c3654ade/6bdcf/react-table-with-virtuoso.png 315w,\n/static/204ce51fbe264a47e9b09154c3654ade/f058b/react-table-with-virtuoso.png 630w,\n/static/204ce51fbe264a47e9b09154c3654ade/40601/react-table-with-virtuoso.png 945w,\n/static/204ce51fbe264a47e9b09154c3654ade/78612/react-table-with-virtuoso.png 1260w,\n/static/204ce51fbe264a47e9b09154c3654ade/50e7d/react-table-with-virtuoso.png 1738w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span>\n<a href=\"https://codesandbox.io/s/react-table-with-react-virtuoso-hgps2p?file=/src/Table.js\">https://codesandbox.io/s/react-table-with-react-virtuoso-hgps2p?file=/src/Table.js</a></p>\n<p>React table, react-virtuoso의 사용방법은 첨부한 codesandbox 링크를 참조</p>\n<p>참고자료\n<a href=\"https://web.dev/virtualize-long-lists-react-window/\">https://web.dev/virtualize-long-lists-react-window/</a></p>","frontmatter":{"title":"React Virtuoso를 사용하여 React-table 의 느린 성능 개선하기","tags":["react","table","react-table","react-virtuoso","virtualization"],"date":"June 10, 2023","description":"가상화 테크닉을 사용하여 과도한 렌더로 빚어지는 react-table의 성능을 개선하자"}},"prev":{"frontmatter":{"title":"React Hook Form 렌더링 성능 최적화 하기"},"fields":{"slug":"/blog/optimizing-rendering-performance/"}},"next":{"frontmatter":{"title":"React CRA에서 prop-types와 jsdoc 함께 사용해서 VS Code의 Auto Suggestion 기능 사용하기"},"fields":{"slug":"/blog/using-proptypes-jsdoc/"}}},"pageContext":{"slug":"/blog/improve-react-table-performance/","prevSlug":"/blog/optimizing-rendering-performance/","nextSlug":"/blog/using-proptypes-jsdoc/"}},"staticQueryHashes":["2555585279","2841359383","3159585216"]}