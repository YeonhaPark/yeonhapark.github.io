{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/react-inline-styling/","result":{"data":{"markdownRemark":{"id":"ad605be5-bf32-5168-b3a5-45e2d59f9154","html":"<p>리액트에서 인라인 스타일링을 할 때 보통 아래처럼 코드를 작성한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">MyApp</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token operator\">&lt;</span>div style<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span> marginTop<span class=\"token operator\">:</span> <span class=\"token number\">10</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span><span class=\"token operator\">></span>\n      Hi there<span class=\"token operator\">!</span>\n      <span class=\"token operator\">&lt;</span>button<span class=\"token operator\">></span>Button<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>button<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>하지만 위처럼 코드를 작성하게 되면 MyApp이 매번 렌더링 될 때마다 객체인 <code class=\"language-text\">{ marginTop: 10 }</code> 이 재정의되며, div 태그에 속하는 하위 요소들까지 다시 생성한다. 작성하는 입장에서는 똑같은 코드 같아 보여도, 자바스크립트는 이를 다르게 인식하는 것이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 254px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/011b7762c16b7964b9a744d3fcf1126c/6a91e/object-compare.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 89.16666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAABYlAAAWJQFJUiTwAAACr0lEQVQ4y4VUyXLTQBD1bxCjXSNLkaJ9sSXvsnEMCURJGVJQ4cadI3//6B47IZvDoWtqemZe9+vXPT0hBIIggGEYyLIc7XqDMIwwcCzEkYuEzHNteKe+PBuOannXtu1Xree6LpbLFrquo24muLreIcsrNJWLu28lft6WWE5P4QcRupsd5osWBt09CmhZlgTj1bJNuJ6gDFQyDarWh6YrdGbL81PKcjAYwDTNPQD5XgB6noeyrKATSJGu0RQdhtkWedKiojWNZjBMTV5mIOsAIhN4xXpJkuDy8rPMKI2muFz9xqL5gcnwBt3mD5ryioIpEMKRQELYR+nKDFkUjsy1tGyDHvcpIwWmpUEzTsink0AOHNuCcIiu5RBt2rOP3jIIl+HeenwQx7EEDf0MeTxBkcyQhiOMijUCL4ag2rlJCd+zMa59WVNWfNGuEMXJU8qMOp/PKbJBtVtiM7vFsunQjq9xPv+OMzdCUE+Rbr8i8i18aENJ//zjhbRFu/4n0r3KqqpKdD4wDJOUVWWv6boGYYuDX4em6VCUfUcwMy4XJ2Q9Urvn+z6appEAYRiirEpSvSRfjdFohDzPURTFg7H/ucpPRGGQ7XYre7GqKkwmEwyHFRaLOeq6xhlNEQdk8Ol0KtdjLSNryGlzdqwyrxbRMy1BtC2iyNH37cIBH9M8ZlIUpsUPVqtWznOeOlT8COerCEXmIE1pxttWBhSHVjnahwzIVBRFwW63w3g8pSkRuDinht8mKDMhZ7zrOspYe3NKJGVWkMH4Ij/QaWJYzXf9E/Tfq7Tfq68fPgTrlfl9kiF/XXs6Go3ZF4yrjhr6E9rJHfXlhqZGpYviv5k9ZMgq8/fFfRYGI2TxAiV9EpvZL/lBmPJjeLtuL2aZkbmWZ2FA80oHgpVWSQD2u2+q+tz+AoKdHTVm242aAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"reference_type_object\"\n        title=\"reference_type_object\"\n        src=\"/static/011b7762c16b7964b9a744d3fcf1126c/6a91e/object-compare.png\"\n        srcset=\"/static/011b7762c16b7964b9a744d3fcf1126c/8ff5a/object-compare.png 240w,\n/static/011b7762c16b7964b9a744d3fcf1126c/6a91e/object-compare.png 254w\"\n        sizes=\"(max-width: 254px) 100vw, 254px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>객체는 새로 생성될 때마다 레퍼런스 값이 생성되기 때문에 위처럼 언뜻 봤을때는 같아 보여도 실제로 비교하면 다른 값이라는 결과가 나오게 된다. 위 그림처럼 <code class=\"language-text\">{}</code> 객체를 생성하고 비교하면 false가 리턴되지만, a라는 변수에 객체를 넣고 a와 a를 비교하면 true가 리턴된다. 이 원리를 리액트 인라인 스타일링에도 적용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> myAppStyle <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> marginTop<span class=\"token operator\">:</span> <span class=\"token number\">10</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">MyApp</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token operator\">&lt;</span>div style<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>myAppStyle<span class=\"token punctuation\">}</span><span class=\"token operator\">></span>\n      Hi there<span class=\"token operator\">!</span>\n      <span class=\"token operator\">&lt;</span>button<span class=\"token operator\">></span>Button<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>button<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이렇게 처리하면 컴포넌트가 리렌더링 될 때 매번 인라인 스타일링의 값이 달라지지 않기 때문에 최적화를 할 수 있다. 이는 비단 인라인 스타일링에만 적용되는 것이 아니라 이벤트 리스너에 따른 이벤트 핸들러 콜백 처리와도 연관된다. 리액트 훅스에서 useCallback을 사용하는 이유도 컴포넌트가 렌더 될 때마다 함수를 재생성하기 떄문에 함수를 재생성하는 조건을 받아서 이에 따르는 비효율을 최소화하기 위함이다.(해당 내용은 추후에 포스트로 작성하겠다.)</p>\n<p>물론 위와 같이 짤막한 코드나 간단한 인라인 스타일링의 경우까지 변수 지정을 해서 매번 정의해줄 필요는 없다. 리액트는 충분히 빠르기 때문에 매번 코딩을 할 때마다 리렌더링과 최적화 그리고 코드치는 속도의 밸런스를 잘 조율해가며 개발해야겠다.</p>","fields":{"slug":"/posts/react-inline-styling/","tagSlugs":["/tag/javascript/","/tag/react/","/tag/inline-styling/"]},"frontmatter":{"date":"2020-07-05","description":"","tags":["javascript","react","inline-styling"],"title":"React 인라인 스타일링에 객체를 넣으면 안되는 이유"}}},"pageContext":{"slug":"/posts/react-inline-styling/"}},"staticQueryHashes":["1488695104","251939775","401334301"]}